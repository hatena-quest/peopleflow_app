<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãŸã“ç„¼ãæ³¨æ–‡æ•°äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
            padding: 10px;
        }
        
        .main-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .top-section {
            height: 70%;
            display: flex;
            gap: 10px;
        }
        
        .left-panel {
            width: 60%;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .right-panel {
            width: 40%;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            overflow-y: auto;
        }
        
        .bottom-section {
            height: 30%;
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .prediction-header {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            z-index: 10;
            pointer-events: none;
        }
        
        .prediction-header h2 {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }
        
        .prediction-value-large {
            font-size: 4em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }
        
        .prediction-unit {
            font-size: 1.2em;
            color: #666;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }
        
        .busyness-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 0;
            min-height: 350px;
            padding: 20px;
            flex-wrap: wrap;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1;
        }
        
        .busyness-icon {
            width: 50px;
            height: 50px;
            object-fit: contain;
            transition: all 0.4s ease;
            opacity: 0.3;
            filter: grayscale(0.5);
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .busyness-icon.active {
            width: 300px;
            height: 300px;
            opacity: 1.0 !important;
            filter: grayscale(0) drop-shadow(0 0 25px rgba(0,0,0,0.7));
            z-index: 5;
            transform: none;
        }
        
        .busyness-icon:hover:not(.active) {
            opacity: 0.5;
            transform: scale(1.1);
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 1200px) {
            .busyness-icon {
                width: 45px;
                height: 45px;
            }
            .busyness-icon.active {
                width: 250px;
                height: 250px;
            }
            .busyness-indicator {
                min-height: 300px;
            }
        }
        
        @media (max-width: 768px) {
            .busyness-indicator {
                gap: 8px;
                min-height: 250px;
                padding: 15px;
            }
            .busyness-icon {
                width: 40px;
                height: 40px;
            }
            .busyness-icon.active {
                width: 200px;
                height: 200px;
            }
            .prediction-value-large {
                font-size: 3em;
            }
            .prediction-header {
                right: 15px;
                top: 15px;
            }
        }
        
        .graph-container {
            flex: 1;
            margin-top: 320px;
            min-height: 150px;
            position: relative;
        }
        
        .graph-canvas {
            width: 100%;
            height: 100%;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
        }
        
        .accuracy-display {
            text-align: center;
            margin-top: 10px;
            font-size: 1.1em;
            color: #666;
        }
        
        .accuracy-value {
            font-weight: bold;
            color: #28a745;
            font-size: 1.3em;
        }
        
        .reasons-title {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .reason-item {
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            border-radius: 5px;
        }
        
        .reason-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .reason-label {
            font-weight: bold;
            color: #667eea;
            font-size: 0.95em;
        }
        
        .reason-impact {
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .reason-impact.positive {
            color: #28a745;
        }
        
        .reason-impact.negative {
            color: #dc3545;
        }
        
        .reason-detail {
            font-size: 0.85em;
            color: #666;
        }
        
        .console-area {
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #333;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            overflow-y: auto;
            max-height: 100%;
        }
        
        .console-log {
            margin-bottom: 5px;
            padding: 3px 0;
        }
        
        .console-timestamp {
            color: #666;
            margin-right: 10px;
        }
        
        .dummy-control {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }
        
        .dummy-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: #666;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .status-indicator.running {
            background: #28a745;
            box-shadow: 0 0 8px #28a745;
        }
        
        .status-indicator.stopped {
            background: #dc3545;
        }
        
        .btn {
            padding: 10px 25px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            min-width: 100px;
        }
        
        .btn-start {
            background: #28a745;
            color: white;
        }
        
        .btn-start:hover:not(:disabled) {
            background: #218838;
            transform: scale(1.05);
        }
        
        .btn-stop {
            background: #dc3545;
            color: white;
        }
        
        .btn-stop:hover:not(:disabled) {
            background: #c82333;
            transform: scale(1.05);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .loading {
            text-align: center;
            color: #666;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- ä¸Šæ®µï¼ˆ70%ï¼‰ -->
        <div class="top-section">
            <!-- å·¦ãƒ‘ãƒãƒ«ï¼ˆ60%ï¼‰ -->
            <div class="left-panel">
                <div class="prediction-header">
                    <h2>10åˆ†å¾Œã®äºˆæ¸¬æ³¨æ–‡æ•°</h2>
                    <div class="prediction-value-large" id="prediction">-</div>
                    <div class="prediction-unit">å€‹</div>
                </div>
                
                <div class="busyness-indicator" id="busynessIndicator">
                    <img src="{{ url_for('static', filename='level1.png') }}" class="busyness-icon" id="busy0" alt="ãƒ¬ãƒ™ãƒ«1">
                    <img src="{{ url_for('static', filename='level2.png') }}" class="busyness-icon" id="busy1" alt="ãƒ¬ãƒ™ãƒ«2">
                    <img src="{{ url_for('static', filename='level3.png') }}" class="busyness-icon" id="busy2" alt="ãƒ¬ãƒ™ãƒ«3">
                    <img src="{{ url_for('static', filename='level4.png') }}" class="busyness-icon" id="busy3" alt="ãƒ¬ãƒ™ãƒ«4">
                    <img src="{{ url_for('static', filename='level5.png') }}" class="busyness-icon" id="busy4" alt="ãƒ¬ãƒ™ãƒ«5">
                </div>
                
                <div class="graph-container">
                    <canvas class="graph-canvas" id="graphCanvas"></canvas>
                </div>
                
                <div class="accuracy-display">
                    äºˆæ¸¬ä¸€è‡´ç‡: <span class="accuracy-value" id="accuracy">-</span>%
                </div>
            </div>
            
            <!-- å³ãƒ‘ãƒãƒ«ï¼ˆ40%ï¼‰ -->
            <div class="right-panel">
                <div class="reasons-title">ğŸ“Š äºˆæ¸¬ã®æ ¹æ‹ </div>
                <div id="reasons">
                    <div class="loading">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
                </div>
            </div>
        </div>
        
        <!-- ä¸‹æ®µï¼ˆ30%ï¼‰ -->
        <div class="bottom-section">
            <div class="console-area" id="console">
                <div class="console-log">
                    <span class="console-timestamp">[ã‚·ã‚¹ãƒ†ãƒ ]</span> ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ ãŒèµ·å‹•ã—ã¾ã—ãŸã€‚
                </div>
            </div>
            
            <div class="dummy-control">
                <div class="dummy-status">
                    <span class="status-indicator stopped" id="statusIndicator"></span>
                    <span id="statusText">ãƒ€ãƒŸãƒ¼: åœæ­¢ä¸­</span>
                </div>
                <div>
                    <button class="btn btn-start" id="startBtn" onclick="startDummy()">é–‹å§‹</button>
                    <button class="btn btn-stop" id="stopBtn" onclick="stopDummy()" disabled>åœæ­¢</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let updateInterval;
        let predictionHistory = [];  // {timestamp: Date, prediction: number, actual: number|null}[]
        let graphCanvas, graphCtx;
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // ã‚°ãƒ©ãƒ•ã‚­ãƒ£ãƒ³ãƒã‚¹ã®åˆæœŸåŒ–
            graphCanvas = document.getElementById('graphCanvas');
            graphCtx = graphCanvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // åˆæœŸæ›´æ–°
            updatePrediction();
            updateDummyStatus();
            
            // 5ç§’ã”ã¨ã«äºˆæ¸¬ã‚’æ›´æ–°
            updateInterval = setInterval(updatePrediction, 5000);
            
            // 10ç§’ã”ã¨ã«ãƒ€ãƒŸãƒ¼çŠ¶æ…‹ã‚’æ›´æ–°
            setInterval(updateDummyStatus, 10000);
            
            // ã‚°ãƒ©ãƒ•ã‚’æç”»
            drawGraph();
        });
        
        function resizeCanvas() {
            const rect = graphCanvas.getBoundingClientRect();
            graphCanvas.width = rect.width;
            graphCanvas.height = rect.height;
            drawGraph();
        }
        
        function getBusynessLevel(prediction) {
            if (prediction < 2) return 0;
            if (prediction < 4) return 1;
            if (prediction < 6) return 2;
            if (prediction < 8) return 3;
            return 4;
        }
        
        function updateBusynessIndicator(prediction) {
            const level = getBusynessLevel(prediction);
            for (let i = 0; i <= 4; i++) {
                const icon = document.getElementById(`busy${i}`);
                if (i === level) {
                    icon.classList.add('active');
                } else {
                    icon.classList.remove('active');
                }
            }
        }
        
        function drawGraph() {
            if (!graphCtx) {
                return;
            }
            
            const canvas = graphCanvas;
            const ctx = graphCtx;
            const width = canvas.width;
            const height = canvas.height;
            
            // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’èª¿æ•´ï¼ˆä¸‹éƒ¨ã«Xè»¸ãƒ©ãƒ™ãƒ«ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç¢ºä¿ï¼‰
            const paddingTop = 30;
            const paddingBottom = 50;  // Xè»¸ãƒ©ãƒ™ãƒ«ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç¢ºä¿
            const paddingLeft = 50;
            const paddingRight = 20;
            const graphWidth = width - paddingLeft - paddingRight;
            const graphHeight = height - paddingTop - paddingBottom;
            
            // ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, width, height);
            
            // èƒŒæ™¯
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // ã€Œç¾åœ¨ã€ã‚’ãƒ‡ãƒ¼ã‚¿ã®æœ€æ–°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¨ã—ã¦å®šç¾©
            let now = new Date(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯PCã®ç¾åœ¨æ™‚åˆ»
            let filteredData = [];
            
            if (predictionHistory && predictionHistory.length > 0) {
                // æœ‰åŠ¹ãªã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
                const validData = predictionHistory.filter(item => {
                    if (!item || !item.timestamp) return false;
                    const itemTime = item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp);
                    return !isNaN(itemTime.getTime());
                });
                
                if (validData.length > 0) {
                    // æœ€æ–°ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ã€Œç¾åœ¨ã€ã¨ã—ã¦å®šç¾©
                    const timestamps = validData.map(item => {
                        return item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp);
                    });
                    now = new Date(Math.max(...timestamps.map(ts => ts.getTime())));
                    
                    // æœ€æ–°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‹ã‚‰60åˆ†å‰ã¾ã§ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
                    filteredData = validData.filter(item => {
                        const itemTime = item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp);
                        return itemTime >= oneHourAgo;
                    });
                    
                    console.log('ã‚°ãƒ©ãƒ•æç”»:', {
                        total: predictionHistory.length,
                        valid: validData.length,
                        filtered: filteredData.length,
                        latestTimestamp: now.toISOString(),
                        oldestInRange: filteredData.length > 0 ? 
                            (filteredData[0].timestamp instanceof Date ? 
                                filteredData[0].timestamp : new Date(filteredData[0].timestamp)).toISOString() : 'ãªã—'
                    });
                }
            }
            
            // Xè»¸ã®ç·šã‚’æç”»ï¼ˆãƒ‡ãƒ¼ã‚¿ãŒãªãã¦ã‚‚æ çµ„ã¿ã¯è¡¨ç¤ºï¼‰
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop + graphHeight);
            ctx.lineTo(width - paddingRight, paddingTop + graphHeight);
            ctx.stroke();
            
            // Yè»¸ã®ç·šã‚’æç”»
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, paddingTop + graphHeight);
            ctx.stroke();
            
            // ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã§ã‚‚ã‚°ãƒ©ãƒ•ã®æ çµ„ã¿ã‚’è¡¨ç¤º
            if (filteredData.length === 0) {
                // ã‚°ãƒªãƒƒãƒ‰ç·šã‚’æç”»
                ctx.strokeStyle = '#e9ecef';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = paddingTop + (graphHeight / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(paddingLeft, y);
                    ctx.lineTo(width - paddingRight, y);
                    ctx.stroke();
                }
                
                // Yè»¸ãƒ©ãƒ™ãƒ«
                ctx.fillStyle = '#666';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const value = (10 / 4) * (4 - i);
                    const y = paddingTop + (graphHeight / 4) * i;
                    ctx.fillText(value.toFixed(0), paddingLeft - 10, y + 4);
                }
                
                // Xè»¸ã®æ™‚åˆ»ãƒ©ãƒ™ãƒ«
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                const xLabelPositions = [0, 15, 30, 45, 60];
                for (const minutesAgo of xLabelPositions) {
                    const x = paddingLeft + (graphWidth * (60 - minutesAgo) / 60);
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, paddingTop + graphHeight);
                    ctx.lineTo(x, paddingTop + graphHeight + 5);
                    ctx.stroke();
                    
                    let label;
                    if (minutesAgo === 0) {
                        label = 'ç¾åœ¨';
                    } else {
                        label = `-${minutesAgo}åˆ†`;
                    }
                    ctx.fillText(label, x, paddingTop + graphHeight + 20);
                }
                
                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                ctx.fillStyle = '#999';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', width / 2, height / 2);
                return;
            }
            
            // Yè»¸ã®æœ€å¤§å€¤ã‚’è¨ˆç®—
            const allValues = filteredData.map(item => item.prediction)
                .concat(filteredData.map(item => item.actual).filter(v => v !== null && !isNaN(v)));
            const maxValue = allValues.length > 0 ? Math.max(8, ...allValues) * 1.1 : 10;
            
            // Yè»¸ã®ç·šã‚’æç”»
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, paddingTop + graphHeight);
            ctx.stroke();
            
            // ã‚°ãƒªãƒƒãƒ‰ç·šã‚’æç”»
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = paddingTop + (graphHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(paddingLeft, y);
                ctx.lineTo(width - paddingRight, y);
                ctx.stroke();
            }
            
            // Yè»¸ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#666';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const value = (maxValue / 4) * (4 - i);
                const y = paddingTop + (graphHeight / 4) * i;
                ctx.fillText(value.toFixed(0), paddingLeft - 10, y + 4);
            }
            
            // Yè»¸ã®ã‚¿ã‚¤ãƒˆãƒ«
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('æ³¨æ–‡æ•°ï¼ˆå€‹ï¼‰', 0, 0);
            ctx.restore();
            
            // Xè»¸ã®æ™‚åˆ»ãƒ©ãƒ™ãƒ«ã‚’è¨ˆç®—
            // å·¦ç«¯ãŒ60åˆ†å‰ã€å³ç«¯ãŒç¾åœ¨
            const timeRange = 60; // 60åˆ†
            const xLabelPositions = [0, 15, 30, 45, 60]; // 0åˆ†å‰ã€15åˆ†å‰ã€30åˆ†å‰ã€45åˆ†å‰ã€60åˆ†å‰ï¼ˆç¾åœ¨ï¼‰
            
            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            
            // Xè»¸ã®ç›®ç››ã‚Šã¨ãƒ©ãƒ™ãƒ«ã‚’æç”»
            for (const minutesAgo of xLabelPositions) {
                const x = paddingLeft + (graphWidth * (60 - minutesAgo) / 60);
                
                // ç›®ç››ã‚Šç·šã‚’æç”»
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, paddingTop + graphHeight);
                ctx.lineTo(x, paddingTop + graphHeight + 5);
                ctx.stroke();
                
                // ãƒ©ãƒ™ãƒ«ã‚’æç”»
                let label;
                if (minutesAgo === 0) {
                    label = 'ç¾åœ¨';
                } else {
                    label = `-${minutesAgo}åˆ†`;
                }
                ctx.fillText(label, x, paddingTop + graphHeight + 20);
            }
            
            // Xè»¸ã®ã‚¿ã‚¤ãƒˆãƒ«
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('æ™‚åˆ»ï¼ˆéå»1æ™‚é–“ï¼‰', width / 2, height - 10);
            
            // ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’æ™‚åˆ»ã«åŸºã¥ã„ã¦é…ç½®
            // äºˆæ¸¬å€¤ã®ç·šã‚’æç”»
            if (filteredData.length > 0) {
                // ãƒ‡ãƒ¼ã‚¿ã‚’æ™‚åˆ»é †ã«ã‚½ãƒ¼ãƒˆ
                const sortedData = filteredData.slice().sort((a, b) => {
                    const timeA = a.timestamp instanceof Date ? a.timestamp : new Date(a.timestamp);
                    const timeB = b.timestamp instanceof Date ? b.timestamp : new Date(b.timestamp);
                    return timeA - timeB;
                });
                
                console.log('æç”»ã™ã‚‹ãƒ‡ãƒ¼ã‚¿:', sortedData.length, 'ä»¶');
                
                // äºˆæ¸¬å€¤ã®ç‚¹ã‚’å…ˆã«æç”»ï¼ˆãƒ‡ãƒ¼ã‚¿ãŒ1ã¤ã§ã‚‚è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
                ctx.fillStyle = '#667eea';
                const validPoints = [];
                for (const item of sortedData) {
                    const itemTime = item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp);
                    if (isNaN(itemTime.getTime())) {
                        console.log('ç„¡åŠ¹ãªã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆæç”»æ™‚ï¼‰:', item);
                        continue;
                    }
                    
                    const minutesAgo = (now - itemTime) / (1000 * 60); // åˆ†å˜ä½
                    const x = paddingLeft + (graphWidth * (60 - minutesAgo) / 60);
                    const y = paddingTop + graphHeight - (item.prediction / maxValue) * graphHeight;
                    
                    // Xè»¸ã®ç¯„å›²å†…ã«åã¾ã‚‹ã‚ˆã†ã«ï¼ˆå°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
                    if (x >= paddingLeft - 10 && x <= width - paddingRight + 10 && !isNaN(y) && !isNaN(x)) {
                        validPoints.push({ x, y, item });
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        console.log('ç¯„å›²å¤–ã®ãƒã‚¤ãƒ³ãƒˆ:', { x, y, minutesAgo, prediction: item.prediction });
                    }
                }
                
                // ç·šã‚’æç”»ï¼ˆ2ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
                if (validPoints.length > 1) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(validPoints[0].x, validPoints[0].y);
                    for (let i = 1; i < validPoints.length; i++) {
                        ctx.lineTo(validPoints[i].x, validPoints[i].y);
                    }
                    ctx.stroke();
                }
            }
            
            // å®Ÿéš›ã®æ³¨æ–‡æ•°ã®ç·šã‚’æç”»
            const actualDataPoints = filteredData.filter(item => 
                item.actual !== null && item.actual !== undefined && !isNaN(item.actual)
            );
            if (actualDataPoints.length > 0) {
                // ãƒ‡ãƒ¼ã‚¿ã‚’æ™‚åˆ»é †ã«ã‚½ãƒ¼ãƒˆ
                const sortedActualData = actualDataPoints.slice().sort((a, b) => {
                    const timeA = a.timestamp instanceof Date ? a.timestamp : new Date(a.timestamp);
                    const timeB = b.timestamp instanceof Date ? b.timestamp : new Date(b.timestamp);
                    return timeA - timeB;
                });
                
                if (sortedActualData.length > 1) {
                    ctx.strokeStyle = '#28a745';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    let firstPoint = true;
                    for (const item of sortedActualData) {
                        const itemTime = item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp);
                        if (isNaN(itemTime.getTime())) continue;
                        
                        const minutesAgo = (now - itemTime) / (1000 * 60);
                        const x = paddingLeft + (graphWidth * (60 - minutesAgo) / 60);
                        const y = paddingTop + graphHeight - (item.actual / maxValue) * graphHeight;
                        
                        if (x >= paddingLeft && x <= width - paddingRight && !isNaN(y)) {
                            if (firstPoint) {
                                ctx.moveTo(x, y);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                    }
                    if (!firstPoint) {
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }
                
                // å®Ÿéš›ã®æ³¨æ–‡æ•°ã®ç‚¹ã‚’æç”»
                ctx.fillStyle = '#28a745';
                for (const item of sortedActualData) {
                    const itemTime = item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp);
                    if (isNaN(itemTime.getTime())) continue;
                    
                    const minutesAgo = (now - itemTime) / (1000 * 60);
                    const x = paddingLeft + (graphWidth * (60 - minutesAgo) / 60);
                    const y = paddingTop + graphHeight - (item.actual / maxValue) * graphHeight;
                    
                    if (x >= paddingLeft && x <= width - paddingRight && !isNaN(y)) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // å‡¡ä¾‹
            ctx.font = '11px sans-serif';
            ctx.fillStyle = '#667eea';
            ctx.fillRect(width - 120, 10, 15, 2);
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.fillText('äºˆæ¸¬', width - 100, 15);
            
            ctx.fillStyle = '#28a745';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(width - 120, 25);
            ctx.lineTo(width - 105, 25);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#333';
            ctx.fillText('å®Ÿæ¸¬', width - 100, 28);
        }
        
        function calculateAccuracy() {
            if (predictionHistory.length === 0) {
                return null;
            }
            
            let matches = 0;
            let count = 0;
            
            for (const item of predictionHistory) {
                if (item.actual !== null) {
                    const diff = Math.abs(item.prediction - item.actual);
                    if (diff <= 1) { // 1å€‹ä»¥å†…ã®èª¤å·®ã‚’ä¸€è‡´ã¨ã¿ãªã™
                        matches++;
                    }
                    count++;
                }
            }
            
            return count > 0 ? (matches / count * 100).toFixed(1) : null;
        }
        
        function addConsoleLog(message, type = 'info') {
            const console = document.getElementById('console');
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const log = document.createElement('div');
            log.className = 'console-log';
            log.innerHTML = `<span class="console-timestamp">[${timestamp}]</span> ${message}`;
            console.appendChild(log);
            console.scrollTop = console.scrollHeight;
            
            // ãƒ­ã‚°ãŒå¤šã™ãã‚‹å ´åˆã¯å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
            while (console.children.length > 50) {
                console.removeChild(console.firstChild);
            }
        }
        
        // äºˆæ¸¬ã‚’æ›´æ–°
        async function updatePrediction() {
            try {
                const response = await fetch('/api/predict');
                const data = await response.json();
                
                if (data.error) {
                    document.getElementById('prediction').textContent = 'ã‚¨ãƒ©ãƒ¼';
                    addConsoleLog(`ã‚¨ãƒ©ãƒ¼: ${data.error}`, 'error');
                    return;
                }
                
                const prediction = parseFloat(data.prediction);
                document.getElementById('prediction').textContent = prediction.toFixed(1);
                
                // å¿™ã—ã•ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã‚’æ›´æ–°
                updateBusynessIndicator(prediction);
                
                // äºˆæ¸¬å±¥æ­´ã«è¿½åŠ ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãï¼‰
                let timestamp;
                if (data.timestamp) {
                    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æ–‡å­—åˆ—ã‚’Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
                    timestamp = new Date(data.timestamp);
                    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒç„¡åŠ¹ãªå ´åˆã¯ç¾åœ¨æ™‚åˆ»ã‚’ä½¿ç”¨
                    if (isNaN(timestamp.getTime())) {
                        timestamp = new Date();
                    }
                } else {
                    timestamp = new Date();
                }
                
                const actualOrder = data.actual_order !== null && data.actual_order !== undefined ? data.actual_order : null;
                
                predictionHistory.push({
                    timestamp: timestamp,
                    prediction: prediction,
                    actual: actualOrder
                });
                
                // ãƒ‡ãƒ¼ã‚¿ã¯ä¿æŒã—ã€ã‚°ãƒ©ãƒ•æç”»æ™‚ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹
                // ï¼ˆãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒå®Ÿéš›ã®æ™‚åˆ»ã¨åŒæœŸã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ï¼‰
                // ãŸã ã—ã€ã‚ã¾ã‚Šã«å¤ã„ãƒ‡ãƒ¼ã‚¿ï¼ˆä¾‹ï¼š1æ—¥ä»¥ä¸Šå‰ï¼‰ã¯å‰Šé™¤
                const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
                predictionHistory = predictionHistory.filter(item => {
                    const itemTime = item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp);
                    return !isNaN(itemTime.getTime()) && itemTime >= oneDayAgo;
                });
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆé–‹ç™ºæ™‚ã®ã¿ï¼‰
                console.log('ãƒ‡ãƒ¼ã‚¿è¿½åŠ :', {
                    timestamp: timestamp.toISOString(),
                    prediction: prediction,
                    actual: actualOrder,
                    historyLength: predictionHistory.length,
                    allTimestamps: predictionHistory.map(item => 
                        (item.timestamp instanceof Date ? item.timestamp : new Date(item.timestamp)).toISOString()
                    )
                });
                
                if (actualOrder !== null) {
                    addConsoleLog(`å®Ÿæ¸¬å€¤: ${actualOrder}å€‹ï¼ˆäºˆæ¸¬: ${prediction.toFixed(1)}å€‹ï¼‰`);
                }
                
                // ã‚°ãƒ©ãƒ•ã‚’å†æç”»
                drawGraph();
                
                // ä¸€è‡´ç‡ã‚’æ›´æ–°
                const accuracy = calculateAccuracy();
                if (accuracy !== null) {
                    document.getElementById('accuracy').textContent = accuracy;
                }
                
                addConsoleLog(`äºˆæ¸¬æ›´æ–°: ${prediction.toFixed(1)}å€‹`);
                
                // æ ¹æ‹ ã‚’è¡¨ç¤º
                const reasonsDiv = document.getElementById('reasons');
                if (data.reasons && data.reasons.length > 0) {
                    reasonsDiv.innerHTML = data.reasons.slice(0, 5).map(reason => `
                        <div class="reason-item">
                            <div class="reason-item-header">
                                <div class="reason-label">${reason.camera} ${reason.direction}</div>
                                <div class="reason-impact ${reason.impact > 0 ? 'positive' : 'negative'}">
                                    ${reason.impact > 0 ? '+' : ''}${reason.impact.toFixed(2)}
                                </div>
                            </div>
                            <div class="reason-detail">${reason.count}äºº/min</div>
                        </div>
                    `).join('');
                } else {
                    reasonsDiv.innerHTML = '<div class="loading">æ ¹æ‹ ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
                }
                
            } catch (error) {
                console.error('äºˆæ¸¬æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                document.getElementById('prediction').textContent = 'ã‚¨ãƒ©ãƒ¼';
                addConsoleLog(`äºˆæ¸¬æ›´æ–°ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        // ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”ŸæˆçŠ¶æ…‹ã‚’æ›´æ–°
        async function updateDummyStatus() {
            try {
                const response = await fetch('/api/dummy/status');
                const data = await response.json();
                
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                if (data.running) {
                    indicator.className = 'status-indicator running';
                    statusText.textContent = 'ãƒ€ãƒŸãƒ¼: å®Ÿè¡Œä¸­';
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                } else {
                    indicator.className = 'status-indicator stopped';
                    statusText.textContent = 'ãƒ€ãƒŸãƒ¼: åœæ­¢ä¸­';
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
            } catch (error) {
                console.error('çŠ¶æ…‹æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚’é–‹å§‹
        async function startDummy() {
            try {
                const response = await fetch('/api/dummy/start', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.status === 'success') {
                    addConsoleLog('ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚', 'success');
                    updateDummyStatus();
                } else {
                    addConsoleLog(`ã‚¨ãƒ©ãƒ¼: ${data.message}`, 'error');
                }
            } catch (error) {
                console.error('é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
                addConsoleLog(`é–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        // ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚’åœæ­¢
        async function stopDummy() {
            try {
                const response = await fetch('/api/dummy/stop', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.status === 'success') {
                    addConsoleLog('ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚’åœæ­¢ã—ã¾ã—ãŸã€‚', 'success');
                    updateDummyStatus();
                } else {
                    addConsoleLog(`ã‚¨ãƒ©ãƒ¼: ${data.message}`, 'error');
                }
            } catch (error) {
                console.error('åœæ­¢ã‚¨ãƒ©ãƒ¼:', error);
                addConsoleLog(`åœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>
